---
title: "`sport` an R package for online update algorithms"
output:
  github_document:
    pandoc_args: --webtex
---

[![Project Status](http://www.repostatus.org/badges/latest/active.svg)](http://www.repostatus.org/#active)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

# About
Package contains functions calculating ratings for two-player or multi-player matchups. Methods included in package are able to estimate players ratings and their evolution in time, also able to predict output of challange. 
Algorithms are based on Bayesian Approximation Method, and they don't involve any martix inversions nor likelihood estimation. Weights (parameters) are updated iteratively, and computation doesn't require any additional RAM to make estimation feasible. Additionaly, base of the package is writen in `C++` what makes `sport` computation even faster.

# Theory
Problem of sport matchups falls into subject of paired comparison modeling and choice modeling. Estimating player skills is equivalent to estimating preferrence of choice between two alternatives. Just as one product is more preferred over another to buy, similarly better player is more preffered to win over worst. As player and alternative or event and experiment can be used interchangeably, for ease of use sport nomenclature is adapted (player/event).  

Algorithms implemented in a `sport` package works similarly, using Bayesian Approximation Method. Algorithms works as follows:
At the moment player `i` competes with player `q` and both have initial $R_i$ and $R_q$ ratings. According to distribution of the ratings prior probability that player `i` win over player `q` is $\hat{Y_i}$. After event is finished when true result $Y_{iq}$ is observed, initial believe about rating is changed $R_i^{'} \leftarrow R_i$ according to the prediction error $( Y_{iq} - \hat{Y_{iq}}  )$ and some constant $K$.

$$\large R_i^{'} \leftarrow R_i + K * ( Y_{iq} - \hat{Y_{iq}}  )$$
Where: 
    $$\large \hat{Y} = P(X_i > X_j)$$ 
    $$K - learning rate$$

Probability function is based on [Bradley-Terry model](https://en.wikipedia.org/wiki/Bradley%E2%80%93Terry_model) designed to predict outcome of pairwise comparison. For multi-player matchups where output is a ranking, `sport` package uses the same data transformation as in [exploded logit](https://www.jstor.org/stable/270983) - ranking is then presented as combination all possible pairs competing within same event.



## Glicko rating system
Algorithms based on [Mark E. Glickman (1999)](http://www.glicko.net/research/glicko.pdf).

Update Rules:

$$\hat{Y_{ij}} = P(X_i>X_j) = \frac{1}{ 1 + 10^{-g(RD_{ij}) * (R_i-R_j)/400}}$$

$${R'}_i = R_i +  \frac{1}{\frac{1}{{RD}^2_{i}} + \frac{1}{d^2_i}} * \sum_j{g(RD_j) * (Y_{ij} - \hat{Y_{ij}})  }$$

$${RD'}_i = \sqrt{(\frac{1}{{RD}^2_{i}} + \frac{1}{d^2_i}})^{-1}$$

## Glicko2 rating system

Algorithm according to [Mark E. Glickman (2013)](http://www.glicko.net/glicko/glicko2.pdf)

$$ \hat{Y_{ij}} = \frac{1}{1 + e^{-g(\phi_{ij})*(\mu_i  - \mu_j)} }$$

$$ {\phi'}_i = \frac{1}{\sqrt{ \frac{1}{ { {\phi_i}^2 + {\sigma'_i}^2}} + \frac{1}{v}  }}$$

$$ {\mu'_i} = \mu_i + {\phi'}_i * \sum_j{g(\phi_j)*(Y_{ij} - \hat{Y_{ij}})} $$


## Bayesian Bradley Terry

Based on [Ruby C. Weng and Chih-Jen Lin (2011)](http://jmlr.csail.mit.edu/papers/volume12/weng11a/weng11a.pdf)

$$\hat{Y_{ij}} = P(X_i>X_j) = \frac{e^{R_i/c_{i_j}}}{e^{R_i/c_{ij}} + e^{R_j/c_{ij}}} $$

$${R'}_i = R_i + \sum_j{\frac{RD_i^2}{c_{ij}}*(Y_{ij} - \hat{Y_{ij}})}$$

$${RD'}_i = RD_i * [ 1 - \frac{RD_{ij}^2}{RD_i^2}\sum_j{ \gamma_j * (\frac{RD_i}{c_{ij}})^2* \hat{Y_{ij}}\hat{Y_{ji}}   } ]$$



## Dynamic Logistic Regression
This algorithm differs from above in not basing on Bradley Terry model. Dynamic Logistic Regression weights are updated using extended Kalman Filter, which means that it's possible to estimate multiple parameters per individual. 

*William D. Penny and Stephen J. Roberts (1999): Dynamic Logistic Regression, Departament of Electrical and Electronic Engineering, Imperial College*

$$w_t = {w_{t-1}} + \eta_t$$

$$Y_t = g(w_t^Tx_t)$$

$$x_t = x_{it} - x_{jt}$$

$$w_t = w_{t-1} + {\sum{_t}} x_t$$

# Package Usage

## Installation
Install package from github.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# devtools::install_github("gogonzo/sport")
library(sport)
```

## Available Data
Package contains data from Speedway Grand-Prix. There are two data.frames: 
1. `gpheats` - results of each race in all SGP events. Column `rank` is a numeric version of column `position` - rider position in race.
2. `gpsquads` - summarized results of the events, with sum of point and final position.

```{r echo=TRUE, message=FALSE, warning=FALSE}
str(gpheats)
```


## Estimate dynamic ratings

To compute ratings using each algorithms one has to specify formula. For example `formula = rank|id ~ rider` estimates `rider` abilities, with observed outputs `rank` nested within particular event/experiment `id`. This formula can be 


Glicko uses only one parameter per `rider` to describe his overall abilities. Ouput is a ranking within specified event (`rank|id`). One can also specify initial parameters based on prior knowledge. `glicko` estimates `r` and `rd` but glicko2 has additional `sig` parameter, measuring volitality. If not specified, by default `r=1500`, `rd=300`, `sig=0.05`.
```{r message=FALSE, warning=FALSE}
# initial estimates default
list_glicko  <- glicko_run(  formula = rank|id ~ rider , data = gpheats )
list_glicko2 <- glicko2_run( formula = rank|id ~ rider , data = gpheats )
```


```{r message=FALSE, warning=FALSE}
library(magrittr)
unique_riders <- unique(gpheats$rider)
r   <- rep(1500, length(unique_riders) ) %>% setNames(unique_riders)
rd  <- rep(1500, length(unique_riders) ) %>% setNames(unique_riders)
sig <- rep(0.05, length(unique_riders) ) %>% setNames(unique_riders)

list_glicko  <- glicko_run( 
  formula = rank|id ~ rider , 
  r = r, rd = rd, 
  data = gpheats)

list_glicko2 <- glicko2_run( 
  formula = rank|id ~ rider , 
  r = r, rd = rd, sig = sig ,
  data = gpheats)

```


```{r message=FALSE, warning=FALSE}
list_bbt <- bbt_run( formula = rank|id~rider,  data = gpheats )
```



```{r message=FALSE, warning=FALSE}
library(tidyverse);library(magrittr)

```


## Join ratings
```{r message=FALSE, warning=FALSE}
ratings_glicko  <- list_glicko$r %>% rename(r_glicko = r, rd_glicko = rd, rider = names )
ratings_glicko2 <- list_glicko2$r %>% rename(r_glicko2 = r, rd_glicko2 = rd, rider = names )
ratings_bbt     <- list_bbt$r %>% rename(r_bbt = r, rd_bbt = rd, rider = names )

gpheats %<>%
  mutate( id = as.character(id)) %>%
  left_join( ratings_glicko ) %>%
  left_join( ratings_glicko2 ) %>%
  left_join( ratings_bbt )
```

## Join pairs
```{r message=FALSE, warning=FALSE}
pairs_glicko  <- list_glicko[[2]]  %>% rename(P_glicko = P)
pairs_glicko2 <- list_glicko2[[2]] %>% rename(P_glicko2 = P)
pairs_bbt     <- list_bbt[[2]]     %>% rename(P_bbt = P)

pairs <-
  pairs_glicko %>%
  left_join(pairs_glicko2) %>%
  left_join(pairs_bbt) %>%
  rename(rider = team1, opponent = team2) %>%
  filter(Y!=0.5) %>%
  arrange(id, sample(1:n()))


# leave only unique pairs
pairs$uniq_pair <-
  pairs %>% 
  select(rider,opponent) %>% 
  apply(1,function(x)paste(sort(x), collapse=" - ")) 

pairs %<>% filter(!duplicated(paste(id, uniq_pair)))

```



