---
title: "`sport` an R package for online update algorithms"
output:
  github_document:
    pandoc_args: --webtex
---

[![Project Status](http://www.repostatus.org/badges/latest/active.svg)](http://www.repostatus.org/#active)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

# About
Package contains functions calculating ratings for two-player or multi-player matchups. Methods included in package are able to estimate players ratings and their evolution in time, also able to predict output of challange. 
Algorithms are based on Bayesian Approximation Method, and they don't involve any martix inversions nor likelihood estimation. Weights (parameters) are updated iteratively, and computation doesn't require any additional RAM to make estimation feasible. Additionaly, base of the package is writen in `C++` what makes `sport` computation even faster. 

# Theory
Problem of sport matchups falls into subject of paired comparison modeling and choice modeling. Estimating player skills is equivalent to estimating preferrence of choice between two alternatives. Just as one product is more preferred over another to buy, similarly better player is more preffered to win over worst. As player/event and alternative/experiment can be used interchangeably, for ease of use sport nomenclature is adapted (player/event).  

Algorithms implemented in a `sport` package works similarly, as all using Bayesian Approximation Method. Algorithms works as follows:
At the moment player `i` competes with player `j` while both have initial $R_i$ and $R_j$ ratings. Prior to event, probability that player `i` win over player `j` is $\hat{Y_i}$. After event is finished when true result $Y_{ij}$ is observed, initial believe about rating is changed $R_i^{'} \leftarrow R_i$ according to the prediction error $( Y_{ij} - \hat{Y_{ij}}  )$ and some constant $K$. Updates are summed as player can compete with more than one player in particular event.

$$\large R_i^{'} \leftarrow R_i + \sum_{j \neq i}{ K * ( Y_{ij} - \hat{Y_{ij}}}  )$$
Where: 
    $$\large \hat{Y} = P(X_i > X_j)$$ 
    $$K - learning rate$$

Outcome probability function is based on [Bradley-Terry model](https://en.wikipedia.org/wiki/Bradley%E2%80%93Terry_model) designed to predict outcome of pairwise comparison. For multi-player matchups where output is a ranking, `sport` package uses the same data transformation as in [exploded logit](https://www.jstor.org/stable/270983) - ranking is then presented as combination of all possible pairs competing within same event.

## Glicko rating system
Glicko is the first bayesian online update algorithm incorporating rating volatility to rating and outcome computation. Glicko system is not balanced, and sum of rating rewards of all players are not zero. In one 2-players event, reward of player `i` differs from reward of player `q` as it depends on their individual ratings deviation. Rating values oscillates around `r=1500` with max deviation `rd<=350`.

For deeper knowledge read [Mark E. Glickman (1999)](http://www.glicko.net/research/glicko.pdf).

Update Rules:

$$\hat{Y_{ij}} = P(X_i>X_j) = \frac{1}{ 1 + 10^{-g(RD_{ij}) * (R_i-R_j)/400}}$$

$${R'}_i = R_i +  \frac{1}{\frac{1}{{RD}^2_{i}} + \frac{1}{d^2_i}} * \sum_j{g(RD_j) * (Y_{ij} - \hat{Y_{ij}})  }$$

$${RD'}_i = \sqrt{(\frac{1}{{RD}^2_{i}} + \frac{1}{d^2_i}})^{-1}$$

## Glicko2 rating system
Glicko2 improved predecessor by adding volatile parameter $\sigma_i$ which increase/decrease rating deviation in periods when player performance differs from expected. Sigma is estimated iteratively using Illinois algorithm, which converges quickly not affecting computation time. Rating values oscillates around `r=1500` with max deviation `rd<=350`.

For deeper knowledge read [Mark E. Glickman (2013)](http://www.glicko.net/glicko/glicko2.pdf)

$$ \hat{Y_{ij}} = \frac{1}{1 + e^{-g(\phi_{ij})*(\mu_i  - \mu_j)} }$$

$$ {\phi'}_i = \frac{1}{\sqrt{ \frac{1}{ { {\phi_i}^2 + {\sigma'_i}^2}} + \frac{1}{v}  }}$$

$$ {\mu'_i} = \mu_i + {\phi'}_i * \sum_j{g(\phi_j)*(Y_{ij} - \hat{Y_{ij}})} $$


## Bayesian Bradley Terry
The fastest algorithm with simple formula. Original BT formula lacks variance parameter, and this method incorporates rating deviation into model. BBT also prevents against fast `rd` decline to zero using `gamma` and `kappa`.

For deeper knowledge read [Ruby C. Weng and Chih-Jen Lin (2011)](http://jmlr.csail.mit.edu/papers/volume12/weng11a/weng11a.pdf)

$$\hat{Y_{ij}} = P(X_i>X_j) = \frac{e^{R_i/c_{i_j}}}{e^{R_i/c_{ij}} + e^{R_j/c_{ij}}} $$

$${R'}_i = R_i + \sum_j{\frac{RD_i^2}{c_{ij}}*(Y_{ij} - \hat{Y_{ij}})}$$

$${RD'}_i = RD_i * [ 1 - \frac{RD_{ij}^2}{RD_i^2}\sum_j{ \gamma_j * (\frac{RD_i}{c_{ij}})^2* \hat{Y_{ij}}\hat{Y_{ji}}   } ]$$



## Dynamic Bayesian Logit
DBL implements Extended Kalman Filter learning rule, and allows to estimate multiple parameters not just player ratings. DBL is extended to usage in pairwise comparisons by modeling differences of skills. 

$$Y_t = \frac{ e^{w _t^Tx_t} }{1+e^{w _t^Tx_t}}$$

$$x_t = x_{it} - x_{jt}$$


For deeper knowledge read  *William D. Penny and Stephen J. Roberts (1999): Dynamic Logistic Regression, Departament of Electrical and Electronic Engineering, Imperial College*


# Package Usage

## Installation
Install package from github.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# devtools::install_github("gogonzo/sport")
library(sport)
```

## Available Data
Package contains actual data from Speedway Grand-Prix. There are two data.frames: 
1. `gpheats` - results of each race in all SGP events. Column `rank` is a numeric version of column `position` - rider position in race.
2. `gpsquads` - summarized results of the events, with sum of point and final position.

```{r echo=TRUE, message=FALSE, warning=FALSE}
str(gpheats)
```

## Estimate dynamic ratings

To compute ratings using each algorithms one has to specify formula. Following manner is required - `formula = rank|id ~ name` - which estimates `name` (of a player) abilities, with observed outputs `rank` nested within particular event `id`. Variable names in formula are unrestricted, but model structure remains the same. 

Glicko uses only one parameter `name` to describe player overall abilities. Ouput is a ranking within specified event (`rank|id`). One can also specify initial parameters based on prior knowledge estimates `r` and `rd`. By default `r=1500` and `rd=350`
```{r message=FALSE, warning=FALSE}
list_glicko  <- glicko_run(  formula = rank|id ~ rider , data = gpheats )
```

Glicko2 has additional `sig` parameter, measuring volitality. If not specified, by default `r=1500`, `rd=350`, `sig=0.05`.
```{r message=FALSE, warning=FALSE}
list_glicko2 <- glicko2_run( formula = rank|id ~ rider , data = gpheats )
```


```{r message=FALSE, warning=FALSE}
library(magrittr)
unique_riders <- unique(gpheats$rider)
r   <- rep(1500, length(unique_riders) ) %>% setNames(unique_riders)
rd  <- rep(1500, length(unique_riders) ) %>% setNames(unique_riders)
sig <- rep(0.05, length(unique_riders) ) %>% setNames(unique_riders)

list_glicko  <- glicko_run( 
  formula = rank|id ~ rider , 
  r = r, rd = rd, 
  data = gpheats)

list_glicko2 <- glicko2_run( 
  formula = rank|id ~ rider , 
  r = r, rd = rd, sig = sig ,
  data = gpheats)

```


```{r message=FALSE, warning=FALSE}
list_bbt <- bbt_run( formula = rank|id~rider,  data = gpheats )
```



```{r message=FALSE, warning=FALSE}
library(tidyverse);library(magrittr)

```


## Join ratings
```{r message=FALSE, warning=FALSE}
ratings_glicko  <- list_glicko$r %>% rename(r_glicko = r, rd_glicko = rd, rider = names )
ratings_glicko2 <- list_glicko2$r %>% rename(r_glicko2 = r, rd_glicko2 = rd, rider = names )
ratings_bbt     <- list_bbt$r %>% rename(r_bbt = r, rd_bbt = rd, rider = names )

gpheats %<>%
  mutate( id = as.character(id)) %>%
  left_join( ratings_glicko ) %>%
  left_join( ratings_glicko2 ) %>%
  left_join( ratings_bbt )
```

## Join pairs
```{r message=FALSE, warning=FALSE}
pairs_glicko  <- list_glicko[[2]]  %>% rename(P_glicko = P)
pairs_glicko2 <- list_glicko2[[2]] %>% rename(P_glicko2 = P)
pairs_bbt     <- list_bbt[[2]]     %>% rename(P_bbt = P)

pairs <-
  pairs_glicko %>%
  left_join(pairs_glicko2) %>%
  left_join(pairs_bbt) %>%
  rename(rider = team1, opponent = team2) %>%
  filter(Y!=0.5) %>%
  arrange(id, sample(1:n()))


# leave only unique pairs
pairs$uniq_pair <-
  pairs %>% 
  select(rider,opponent) %>% 
  apply(1,function(x)paste(sort(x), collapse=" - ")) 

pairs %<>% filter(!duplicated(paste(id, uniq_pair)))

```



