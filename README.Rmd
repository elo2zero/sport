---
title: "`sport` an R package for bayesian dynamic rating system"
output:
  github_document:
    pandoc_args: --webtex
---

[![Project Status](http://www.repostatus.org/badges/latest/active.svg)](http://www.repostatus.org/#active)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

# About
Package contains functions calculating ratings for two-player or multi-player matchups. Methods are based on Bayesian Approximation Method, and their idea can be summarized by:

$$\large R_i^{'} \leftarrow R_i + K * ( Y_i - \hat{Y_i}  )$$
Where: 
    $$\large \hat{Y} = P(X_i > X_j)$$ 
    $$K - learning rate$$

Probability function is based on [Bradley-Terry model](https://en.wikipedia.org/wiki/Bradley%E2%80%93Terry_model) designed to predict outcome of pairwise comparison. For multi-player matchups where output is a ranking, `sport` package uses the same data transformation as in [exploded logit](https://www.jstor.org/stable/270983) - ranking is then presented as combination all possible pairs competing within same event.

# Theory
## Glicko rating system
Algorithms based on [Mark E. Glickman (1999)](http://www.glicko.net/research/glicko.pdf).

Update Rules:


$$\hat{Y_{ij}} = P(X_i>X_j) = \frac{1}{ 1 + 10^{-g(RD_{ij}) * (R_i-R_j)/400}}$$

$${R'}_i = R_i +  \frac{1}{\frac{1}{{RD}^2_{i}} + \frac{1}{d^2_i}} * \sum_j{g(RD_j) * (Y_{ij} - \hat{Y_{ij}})  }$$

$${RD'}_i = \sqrt{(\frac{1}{{RD}^2_{i}} + \frac{1}{d^2_i}})^{-1}$$

## Glicko2 rating system

Algorithm according to [Mark E. Glickman (2013)](http://www.glicko.net/glicko/glicko2.pdf)

$$ \hat{Y_{ij}} = \frac{1}{1 + e^{-g(\phi_{ij})*(\mu_i  - \mu_j)} }$$

$$ {\phi'}_i = \frac{1}{\sqrt{ \frac{1}{ { {\phi_i}^2 + {\sigma'_i}^2}} + \frac{1}{v}  }}$$

$$ {\mu'_i} = \mu_i + {\phi'}_i * \sum_j{g(\phi_j)*(Y_{ij} - \hat{Y_{ij}})} $$


## Dynamic Bradley Terry

Based on [Ruby C. Weng and Chih-Jen Lin (2011)](http://jmlr.csail.mit.edu/papers/volume12/weng11a/weng11a.pdf)
Algorithm based on 'A Bayesian Approximation Method for Online Ranking' by Ruby C. Weng and Chih-Jen Lin

$$\hat{Y_{ij}} = P(X_i>X_j) = \frac{e^{R_i/c_{i_j}}}{e^{R_i/c_{ij}} + e^{R_j/c_{ij}}} $$

$${R'}_i = R_i + \sum_j{\frac{RD_i^2}{c_{ij}}*(Y_{ij} - \hat{Y_{ij}})}$$

$${RD'}_i = RD_i * [ 1 - \frac{RD_{ij}^2}{RD_i^2}\sum_j{ \gamma_j * (\frac{RD_i}{c_{ij}})^2* \hat{Y_{ij}}\hat{Y_{ji}}   } ]$$



## Dynamic Logistic Regression
This algorithm differs from above in not basing on Bradley Terry model. Dynamic Logistic Regression weights are updated using extended Kalman Filter, which means that it's possible to estimate multiple parameters per individual. 

*William D. Penny and Stephen J. Roberts (1999): Dynamic Logistic Regression, Departament of Electrical and Electronic Engineering, Imperial College*

$$w_t = {w_{t-1}} + \eta_t$$

$$Y_t = g(w_t^Tx_t)$$

$$x_t = x_{it} - x_{jt}$$

$$w_t = w_{t-1} + {\sum{_t}} x_t$$

# Installation
Install package from github.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# devtools::install_github("gogonzo/sport")
library(sport)
```

# Package Usage

To compute glicko and glicko2 ratings one has to specify formula. Glicko uses only one parameter per competitor to describe his overall abilities (`rider_name`). Ouput is a ranking within specified event (`rank|id`). One can also specify initial parameters based on prior knowledge. `glicko` estimates `r` and `rd` but glicko2 has additional `sig` parameter, measuring volitality. If not specified, by default `r=1500`, `rd=300`, `sig=0.05`.
```{r message=FALSE, warning=FALSE}
# initial estimates default
list_glicko <- glicko_run( formula = rank|id ~ rider_name , data = gpheats)
list_glicko2 <- glicko2_run( formula = rank|id ~ rider_name , data = gpheats)
```


```{r message=FALSE, warning=FALSE}
library(magrittr)
unique_riders <- unique(gpheats$rider_name)
r   <- rep(1500, length(unique_riders) ) %>% setNames(unique_riders)
rd  <- rep(1500, length(unique_riders) ) %>% setNames(unique_riders)
sig <- rep(0.05, length(unique_riders) ) %>% setNames(unique_riders)

list_glicko  <- glicko_run( 
  formula = rank|id ~ rider_name , 
  r = r, rd = rd, 
  data = gpheats)

list_glicko2 <- glicko2_run( 
  formula = rank|id ~ rider_name , 
  r = r, rd = rd, sig = sig ,
  data = gpheats)

```


```{r message=FALSE, warning=FALSE}
list_bbt <- bbt_run( formula = rank|id~rider_name,  data = gpheats )
```




```{r message=FALSE, warning=FALSE}
list_dlr1 <- dlr_run( formula = rank|id ~ rider_name, data = gpheats )
```



```{r message=FALSE, warning=FALSE}
library(tidyverse);library(magrittr)
riders <- unique(gpheats$rider_name)
stadiums <- unique(gpheats$place)
set.seed(1)
r <- 
  c(
    rep(0, length(riders)) %>% setNames(paste("rider_name:", riders)),
    seq(0.6,0.1, length.out = 6) %>% setNames(paste("field:",1:6))
  ) %>% as.matrix
rd <- 
  c(
    rep(1, length(riders)) %>% setNames(paste("rider_name:", riders)),
    seq(0.6,0.1, length.out = 6) %>% setNames(paste("field:",1:6))
  ) %>% as.matrix

list_dlr <- dlr_run(
    rank|id ~ rider_name + field,
    r = r,
    rd = rd, 
    data = gpheats
  )
```


## Join ratings
```{r message=FALSE, warning=FALSE}
ratings_glicko  <- list_glicko$r %>% rename(r_glicko = r, rd_glicko = rd, rider_name = names )
ratings_glicko2 <- list_glicko2$r %>% rename(r_glicko2 = r, rd_glicko2 = rd, rider_name = names )
ratings_bbt     <- list_bbt$r %>% rename(r_bbt = r, rd_bbt = rd, rider_name = names )
ratings_dlr     <- list_dlr$r %>% rename(r_dlr = r, rd_dlr = rd, rider_name = names )

gpheats %<>%
  mutate( id = as.character(id)) %>%
  left_join( ratings_glicko ) %>%
  left_join( ratings_glicko2 ) %>%
  left_join( ratings_bbt ) %>%
  left_join( ratings_dlr )
```

## Join pairs
```{r message=FALSE, warning=FALSE}
pairs_glicko  <- list_glicko[[2]]  %>% rename(P_glicko = P)
pairs_glicko2 <- list_glicko2[[2]] %>% rename(P_glicko2 = P)
pairs_bbt     <- list_bbt[[2]]     %>% rename(P_bbt = P)
pairs_dlr1    <- list_dlr1[[1]]    %>% rename(P_dlr1 = P)
pairs_dlr     <- list_dlr[[1]]     %>% rename(P_dlr = P)

pairs <-
  pairs_glicko %>%
  left_join(pairs_glicko2) %>%
  left_join(pairs_bbt) %>%
  left_join(pairs_dlr1) %>%
  left_join(pairs_dlr) %>%
  rename(rider_name = team1, opponent = team2) %>%
  filter(Y!=0.5) %>%
  arrange(id, sample(1:n()))


# leave only unique pairs
pairs$uniq_pair <-
  pairs %>% 
  select(rider_name,opponent) %>% 
  apply(1,function(x)paste(sort(x), collapse=" - ")) 

pairs %<>% filter(!duplicated(paste(id, uniq_pair)))

```



